/*
 * -----------------------
 * --- DEVICE HANDLER ----
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 
 
def clientVersion() {
    return "02.04.04"
}

/**
 * ZooZ Enhanced 4 in 1 Motion, Humidity, Illuminance and Temperature Sensor (ZSE40)
 * 
 * Copyright RBoy Apps, redistribution or reuse of code is not allowed without permission
 *
 * Change log:
 * 2018-8-23 - (v02.04.04) Don't show decimal for Humidity in Android devices
 * 2018-8-5 - (v02.04.03) Added Health Check capability
 * 2018-8-2 - (v02.04.02) Added basic support for new ST app
 * 2018-1-31 - (v02.04.01) Fix identification of older v1/v2, update second tile display to show battey and tamper notification and temperature offset if now in decimal points
 * 2018-1-11 - (v02.04.00) Added support for v3 sensor firmware
 * 2017-10-18 - (v02.03.03) Update tile layout with ST mobile app release 2.8.0
 * 2017-8-9 - (v02.03.02) Improved battery reporting at initial pairing and configuration change
 * 2017-8-9 - (v02.03.01) Improved motion detection, quirk in documentation
 * 2017-8-1 - (v02.03.00) Added ability for users to select the default sensor for the Things summary page
 * 2017-7-14 - (v02.02.05) Created a separate device handler for Monoprice, fixed an issue with motion now showing correctly in summary things page
 * 2017-6-5 - (v02.02.04) Added validating for temp sensitivity input in the preferences page (ST fixed Android decimal range crash)
 * 2017-5-4 - (v02.02.03) Updated color scheme to match ST UX recommendations and added support for C and F color schemes
 * 2017-1-21 - (v2.2.2) Added option for humidity offset, added support for Mode 4 Motion Flash for ZSE40 v2, default wake up interval is now 12 hours, added more fingerprints
 * 2017-1-21 - (v2.2.2) Fixed tamper reporting
 * 2017-1-19 - (v2.2.1) Added ability to change icons
 * 2017-1-18 - (v.2.2.0) Added ability to report in Lux instead of % and added capability for tamper alert
 * 2017-1-12 - (v.2.2.0) Added support for Monoprice 15902 4 in 1 generic sensor and motion for tiles
 * 2016-11-5 - Added ability to report code version and name to check for updates
 * 2016-8-29 - Temporarily disabled range input for temperature sensitivity since ST Android app 2.1.6 throws an error while trying to open the page
 * 2016-8-24 - Enhancements to improve pairing and secure join
 * 2016-8-23 - Updated battery icon
 * 2016-8-21 - Initial release
 *
 *  Copyright 2014 SmartThings
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 *
 */

preferences {
    input title: "", description: "ZooZ Enhanced 4 in 1 Motion Sensor Device Handler v${clientVersion()}", displayDuringSetup: false, type: "paragraph", element: "paragraph"
	input title: "", description: "Leave setting empty to use the device default value\n\nPUSH THE Z-WAVE BUTTON IN THE TINY HOLE AFTER CONFIGURING THESE OPTIONS FOR THEM TO TAKE EFFECT IMMEDIATELY.", displayDuringSetup: false, type: "paragraph", element: "paragraph"
	input title: "", description: "Select the Sensor to show on the 'Things' page", displayDuringSetup: true, type: "paragraph", element: "paragraph"
    input "displaySensor", "enum", title: "Primary Sensor", displayDuringSetup: true, options: ["Motion", "Temperature", "Humidity", "Light"]
	input title: "", description: "Inactive timeout is the number of seconds since the last motion was detected after which the sensor will report no motion (15 to 15300)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "noMotionTimeout", "number", title: "Inactive timeout (seconds)", displayDuringSetup: false, range: "15..15300"
	input title: "", description: "The temperature sensitivity threshold represents how much the temperature levels should change before reporting it. The threshold can vary from 0.1° (very sensitive) to 5° (least sensitive) (default is 1°)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "tempSensitivity", "decimal", title: "Temperature Sensitivity", displayDuringSetup: false, range: "0.1..5.0"
	input title: "", description: "Temperature correction offset is a +ve or -ve number to correct the temperature reported by the sensor", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "tempOffset", "decimal", title: "Temperature correction offset", displayDuringSetup: false, range: "*..*"
	input title: "", description: "Set the motion detection sensitivity level. 1 is MOST sensitive and 7 is LEAST sensitive", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "pirSensitivity", "number", title: "Motion Sensitivity", displayDuringSetup: false, range: "1..7"
	input title: "", description: "The light sensitivity threshold represents what % the light levels should change before reporting it. The threshold can vary from 5% (very sensitive) to 50% (least sensitive) (default is 10%)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "luxSensitivity", "number", title: "Light Sensitivity", displayDuringSetup: false, range: "5..50"
	input title: "", description: "Choose the metric for reporting light levels (default is Lux)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "luxMetric", "enum", title: "Light Reporting Metric", defaultValue: "lux", displayDuringSetup: false, options: ["lux", "%"], required: true
	input title: "", description: "The humidity sensitivity threshold represents what % the humidity levels should change before reporting it. The threshold can vary from 1% (very sensitive) to 50% (least sensitive) (default is 10%)", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "humiditySensitivity", "number", title: "Humidity Sensitivity", displayDuringSetup: false, range: "1..50"
	input title: "", description: "Humidity correction offset is a +ve or -ve number to correct the humidity reported by the sensor", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "humidityOffset", "number", title: "Humidity correction offset", displayDuringSetup: false, range: "*..*"
	input title: "", description: "The LED can work in 4 modes:\n(LED Off) Mode 1 the LED is Off\n(Pulsing) Mode 2 the LED Pulses for a temperature change and Flashes for motion detection (NOTE: This reduces battery life)\n(Quick Flash) Mode 3 the LED flashes for both temperature and motion\n(Motion Flash) Mode 4 the LED flashes for only motion", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "ledConfig", "enum", title: "LED Notifications", displayDuringSetup: false, options: ["LED Off", "Pulsing", "Quick Flash", "Motion Flash"]
	input title: "", description: "If you want to force a manual poll of the temperature/motion/battery status, enter the polling interval in seconds in increments of 200 seconds (minimum 600, maximum 604800, in intervals of 200 seconds). Leave it blank to use the default value\nNOTE: Polling will reduce battery life", displayDuringSetup: false, type: "paragraph", element: "paragraph"
    input "manualPollInterval", "number", title: "Manual Poll Interval (seconds)", displayDuringSetup: false, range: "600..604800"
}

metadata {
    definition (name:"ZooZ 4 in 1 Motion, Humidity, Illuminance and Temperature Sensor (Enhanced)", namespace:"rboy", author: "RBoy Apps", ocfDeviceType: "x.com.st.d.sensor.motion", mnmn: "SmartThings", vid:"SmartThings-smartthings-Aeon_Multisensor") {
		capability "Configuration"
        capability "Sensor"
        capability "Motion Sensor"
        capability "Temperature Measurement"
		capability "Relative Humidity Measurement"
		capability "Illuminance Measurement"
        capability "Battery"
        capability "Tamper Alert"
        capability "Health Check"
        
        attribute "codeVersion", "string"
        attribute "dhName", "string"
        attribute "display", "string"
        attribute "secTile", "string"

        fingerprint deviceId:"0x0701", inClusters: "0x5E,0x86,0x72,0x59,0x85,0x73,0x71,0x84,0x80,0x31,0x70,0x5A,0x98,0x7A", manufacturer: "ZooZ", model: "ZSE40"
        fingerprint deviceId:"0x0701", inClusters: "0x5E,0x86,0x72,0x5A,0x85,0x59,0x73,0x80,0x71,0x31,0x70,0x84,0x7A", manufacturer: "ZooZ", model: "ZSE40 v2"
        
        // New fingerprint format (MSR ==> mfr-prod-model)
        fingerprint type:"0701", cc:"5E,86,72,5A,85,59,73,80,71,31,70,84,7A", mfr:"027A", prod:"2021", model:"2101", deviceJoinName:"ZooZ 4 in 1 Sensor (ZSE40)"
        fingerprint type:"0701", cc:"5E,98", sec:"86,72,5A,85,59,73,80,71,31,70,84,7A", deviceJoinName:"ZooZ 4 in 1 Sensor (ZSE40)"
    }

    tiles(scale: 2) {
        multiAttributeTile(name:"summary", type: "generic", width: 6, height: 4) {
            tileAttribute ("device.motion", key: "PRIMARY_CONTROL") {
                attributeState "active", label:'motion', icon:"st.motion.motion.active", backgroundColor:"#00a0dc"
                attributeState "inactive", label:'no motion', icon:"st.motion.motion.inactive", backgroundColor:"#ffffff"
            }
            tileAttribute ("device.secTile", key: "SECONDARY_CONTROL", canChangeIcon: true) {
				attributeState "secTile", label:'${currentValue}'
            }
        }
		valueTile("temperature", "device.temperature", width: 4, height: 4, canChangeIcon: true) {
			state("temperature", label:'${currentValue}°',
                  backgroundColors:[
                      // Celsius
                      [value: 0, color: "#153591"],
                      [value: 7, color: "#1e9cbb"],
                      [value: 15, color: "#90d2a7"],
                      [value: 23, color: "#44b621"],
                      [value: 28, color: "#f1d801"],
                      [value: 35, color: "#d04e00"],
                      [value: 37, color: "#bc2323"],
                      // Fahrenheit
                      [value: 40, color: "#153591"],
                      [value: 44, color: "#1e9cbb"],
                      [value: 59, color: "#90d2a7"],
                      [value: 74, color: "#44b621"],
                      [value: 84, color: "#f1d801"],
                      [value: 95, color: "#d04e00"],
                      [value: 96, color: "#bc2323"]
                  ]
			)
		}
		valueTile("battery", "device.battery", width: 2, height: 2, inactiveLabel: false, canChangeIcon: true) {
            state "battery", label:'${currentValue}%', unit: "", icon: "http://smartthings.rboyapps.com/images/battery.png", backgroundColors:[
                [value: 15, color: "#ff0000"],
                [value: 30, color: "#fd4e3a"],
                [value: 50, color: "#fda63a"],
                [value: 60, color: "#fdeb3a"],
                [value: 75, color: "#d4fd3a"],
                [value: 90, color: "#7cfd3a"],
                [value: 99, color: "#55fd3a"]
            ]
        }
        valueTile("illuminance","device.illuminanceX", width: 2, height: 2, inactiveLabel: false, canChangeIcon: true) {
            state "luminosity", label:'\n ${currentValue}', icon:"st.Weather.weather14"
        }
        valueTile("humidity", "device.humidity", width: 2, height: 2, inactiveLabel: false, canChangeIcon: true) {
            state "humidity", label:' ${currentValue}%', icon:"st.Weather.weather12", backgroundColors: [
                [value: 20, color: "#ffe700"],
                [value: 30, color: "#d6ff00"],
                [value: 45, color: "#3cff00"],
                [value: 60, color: "#00ffb8"],
                [value: 80, color: "#00dfff"]
            ]
        }
        standardTile("motion", "device.motion", width: 2, height: 2, inactiveLabel: false) {
            state "active", label:'motion', icon:"st.motion.motion.active", backgroundColor:"#00a0dc"
            state "inactive", label:'no motion', icon:"st.motion.motion.inactive", backgroundColor:"#ffffff"
        }
        standardTile("configure", "device.configure", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
			state "default", label:'Request update', action:"configure"
		}
		standardTile("tamper", "device.tamper", width: 2, height: 2) {
			state("detected", label:'TAMPER', backgroundColor:"#e86d13")
			state("clear", label:'', backgroundColor:"#FFFFFF")
		}
        standardTile("display", "device.display", width: 2, height: 2, inactiveLabel: false) {
            state "default", label:'${currentValue}', defaultState: true
            state "active", label:'motion', icon:"st.motion.motion.active", backgroundColor:"#00a0dc"
            state "inactive", label:'no motion', icon:"st.motion.motion.inactive", backgroundColor:"#ffffff"
        }
        
        main "display"
        details(["summary", "temperature", "humidity", "illuminance", "battery", "configure", "tamper"])
    }
}

private Double[] percentTable() {
    return [ 1.0, 22.5, 24.5, 32.5, 40.5, 55.0, 64.5, 74.5, 85.5, 89.0, 97.5, 100.0 ]
}

private Double[] luxTable() {
    return [ 0.0, 1.0, 2.0, 5.0, 10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0 ]
}

def updateSecondaryTile() {
    if (device.currentValue("tamper") == "detected") {
        sendEvent(name: "secTile", value: "Tampter detected", displayed: false)
    } else {
        sendEvent(name: "secTile", value: "Battery ${device.currentValue("battery")}%", displayed: false)
    }
}

def installed() {
	log.trace "Installed called settings: $settings"
	// Device-Watch simply pings if no device events received for 482min(checkInterval)
	sendEvent(name: "checkInterval", value: 2 * 4 * 60 * 60 + 2 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID])
	try {
		if (!state.init) {
			state.init = true
		}
        response(configure()) // Get the updates
	} catch (e) {
		log.warn "updated() threw $e"
	}
}

def updated() {
	log.trace "Update called settings: $settings"
	// Device-Watch simply pings if no device events received for 482min(checkInterval)
	sendEvent(name: "checkInterval", value: 2 * 4 * 60 * 60 + 2 * 60, displayed: false, data: [protocol: "zwave", hubHardwareId: device.hub.hardwareID])
	try {
		if (!state.init) {
			state.init = true
		}
        response(configure()) // Get the updates
	} catch (e) {
		log.warn "updated() threw $e"
	}
}

def parse(String description) {
	//log.trace "$description"
    
	def result = null
	if (description.startsWith("Err 106")) {
		state.security = false // This is a secure communications device we are working with, it's failed
		result = createEvent( name: "secureInclusion", value: "failed", eventType: "ALERT", descriptionText: "This sensor failed to complete the network security key exchange. If you are unable to control it via SmartThings, you must remove it from your network and add it again.")
	} else if (description.startsWith("Err")) {
	    result = createEvent(descriptionText:description)
	} else {
		def cmd = zwave.parse(description, [0x71: 3, 0x31: 5, 0x85: 2, 0x86: 1, 0x84: 2, 0x70: 1, 0x86: 1, 0x98: 1]) // Device support sensorMultiLevel(0x31) is v7 but ST only supports v5, Notification(0x71) is v4 but ST only supports v3, verion(0x86) is v2 but ST only supports v1
		if (cmd) {
			result = zwaveEvent(cmd)
		} else {
			result = createEvent(value: description, descriptionText: description, isStateChange: false)
		}
	}

    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "ZooZ 4 in 1 Enhanced Device Handler"]) // Save DH Name for parent app
    
    runIn(3, updateSecondaryTile) // Update secondary tile after the events have been processed

    log.debug "Parse returned ${result}"
	return result
}

def zwaveEvent(physicalgraph.zwave.commands.securityv1.SecurityMessageEncapsulation cmd) {
    //log.debug "Security cmd: $cmd"
	def encapsulatedCommand = cmd.encapsulatedCommand([0x71: 3,0x31: 5, 0x85: 2, 0x86: 1, 0x84: 2, 0x70: 1, 0x86: 1])
	//log.trace "encapsulated: $encapsulatedCommand"
	if (encapsulatedCommand) {
        state.security = true // This is a secure communications device we are working with
		zwaveEvent(encapsulatedCommand)
	}
}

def resetMotion() {
    log.debug "Resetting motion to inactive"
    sendEvent(name: "motion", value: "inactive", descriptionText: "$device.displayName motion has stopped")
}

def sensorValueEvent(def value) {
    if (!displaySensor || displaySensor == "Motion") { // Update summary display sensor
        sendEvent(name: "display", value: value ? "active" : "inactive")
    }

	if (value) {
		createEvent(name: "motion", value: "active", descriptionText: "$device.displayName detected motion")
	} else {
        if (state.v3 && noMotionTimeout && (noMotionTimeout > 60)) { // v3 firmware has a limit of 60 seconds, handle the rest locally
            log.trace "Resetting motion to inactive in ${noMotionTimeout - 60} seconds"
            runIn((noMotionTimeout - 60), resetMotion)
            createEvent(descriptionText: "$device.displayName resetting motion in ${noMotionTimeout - 60} seconds", displayed: false)
        } else {            
            createEvent(name: "motion", value: "inactive", descriptionText: "$device.displayName motion has stopped")
        }
	}
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicReport cmd)
{
	log.trace "$cmd"
	sensorValueEvent(cmd.value)
}

def zwaveEvent(physicalgraph.zwave.commands.basicv1.BasicSet cmd)
{
	log.trace "$cmd"
	sensorValueEvent(cmd.value)
}

def zwaveEvent(physicalgraph.zwave.commands.switchbinaryv1.SwitchBinaryReport cmd)
{
	log.trace "$cmd"
	sensorValueEvent(cmd.value)
}

def zwaveEvent(physicalgraph.zwave.commands.sensorbinaryv1.SensorBinaryReport cmd)
{
	log.trace "$cmd"
	sensorValueEvent(cmd.sensorValue)
}

def zwaveEvent(physicalgraph.zwave.commands.sensoralarmv1.SensorAlarmReport cmd)
{
	log.trace "$cmd"
	sensorValueEvent(cmd.sensorState)
}

def zwaveEvent(physicalgraph.zwave.commands.notificationv3.NotificationReport cmd)
{
	log.trace "NotificationReport: $cmd"
	def result = []
	if (cmd.notificationType == 0x07) {
        if ((cmd.event == 0x08) || ((cmd.event == 0x00) && (cmd.eventParameter[0] == 0x08))) { // BasicSet and Notification both come in, whichever is faster, bug in documentation, with notification parameter doesn't always contain 0x08
			result << sensorValueEvent(cmd.v1AlarmLevel)
		} else if ((cmd.event == 0x03)) { // Bug, eventParameter is supposed to be 0x03 but it doesn't send it
			result << createEvent(name: "tamper", value: "detected", descriptionText: "$device.displayName covering was removed", isStateChange: true)
		} else if ((cmd.event == 0x00) && (cmd.eventParameter[0] == 0x03)) {
			result << createEvent(name: "tamper", value: "clear", descriptionText: "$device.displayName covering was closed", isStateChange: true)
		}
	} else {
        log.warn "Unknown notification: $cmd"
		result << createEvent(name: "UnknownNotification", descriptionText: cmd.toString(), displayed: true)
    }
    
    result
}

def zwaveEvent(physicalgraph.zwave.commands.wakeupv2.WakeUpNotification cmd)
{
	log.debug "Device woke up"
    
	def event = createEvent(descriptionText: "${device.displayName} woke up", isStateChange: false)
    def cmds = []
    if(!state.MSR) { // Until we have MSR we don't know what product we have, so try both
        log.debug "Getting MSR"
        cmds << zwave.manufacturerSpecificV2.manufacturerSpecificGet()
    }
    
    /*log.debug "Discovering parameters from 1 to 5 from device"
    (1..10).each { parameter ->
    	cmds << zwave.configurationV1.configurationGet(parameterNumber: parameter)
    }*/
    
    switch (state.MSR) {
        default:
        	log.trace "Found Z-Wave device with MSR $state.MSR"
        	break
    }

    if (!state.wakeupSet) { // Configure polling
        if (manualPollInterval) { // Manual poll period set
            log.info "Setting manual poll interval to $manualPollInterval seconds"
            if (!state.security) { // NOTE: ST Platform has a bug, cannot query wake up parameters through secure command right now
                cmds << zwave.wakeUpV2.wakeUpIntervalCapabilitiesGet() // Get Wake up interval capabilities
            }
            cmds << zwave.wakeUpV1.wakeUpIntervalSet(seconds:manualPollInterval, nodeid:zwaveHubNodeId) // Set the wake up interval
            if (!state.security) { // NOTE: ST Platform has a bug, cannot query wake up parameters through secure command right now
                cmds << zwave.wakeUpV1.wakeUpIntervalGet() // Check our current wake up interval
            }
        } else {
            log.info "No manual poll, setting default wake up 12 hours"
            cmds << zwave.wakeUpV1.wakeUpIntervalSet(seconds:12*3600, nodeid:zwaveHubNodeId) // Default: Set the wake up interval to every 12 hours
            if (!state.security) { // NOTE: ST Platform has a bug, cannot query wake up parameters through secure command right now
                cmds << zwave.wakeUpV1.wakeUpIntervalGet() // Check our current wake up interval
            }
        }
        
        state.wakeupSet = true // We're done, don't update again unless requested
    }

    if (!state.configSet) { // Set configuration
        // Set temperature reporting
        if (getTemperatureScale() == "F") {
            log.debug "Setting temperature scale to F"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 1, configurationValue: [1]) // Set to F
        } else {
            log.debug "Setting temperature scale to C"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 1, configurationValue: [0]) // Set to C
        }
        cmds << zwave.configurationV1.configurationGet(parameterNumber: 1)

        if (tempSensitivity && (tempSensitivity >= 0.1 && tempSensitivity <= 5.0)) {
            log.info "Updating temperature reporting threshold to $tempSensitivity°"
            Integer tempSetting = (tempSensitivity * 10) as Integer // Temp reporting threshold is between 1 and 50 with each 1 representing 0.1°
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 2, configurationValue: [tempSetting])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 2)
        } else {
            log.info "Settings temperature reporting threshold to default"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 2, defaultValue: true)
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 2)
        }

        if (humiditySensitivity && (humiditySensitivity >= 1 && humiditySensitivity <= 50)) {
            log.info "Updating humidity reporting threshold to $humiditySensitivity%"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 3, configurationValue: [humiditySensitivity])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 3)
        } else {
            log.info "Settings humidity reporting threshold to default"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 3, defaultValue: true)
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 3)
        }

        if (luxSensitivity && (luxSensitivity >= 1 && luxSensitivity <= 50)) {
            log.info "Updating light reporting threshold to $luxSensitivity%"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 4, configurationValue: [luxSensitivity])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 4)
        } else {
            log.info "Settings light reporting threshold to default"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 4, defaultValue: true)
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 4)
        }

        if (state.v3 && noMotionTimeout) { // v3 has the timeout in seconds
            int timeout = (noMotionTimeout < 15 ? 15 : (noMotionTimeout > 60 ? 60 : noMotionTimeout)) // v3 has limit between 15 and 60 seconds
            log.info "Updating Inactivity timeout to $timeout seconds"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 5, configurationValue: [timeout]) // Set inactivity timeout in seconds
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 5) // Confirm inactivity timeout
        } else if (!state.v3 && noMotionTimeout) { //v2 has the timeout in minutes (inputs from user is in seconds)
            def timeout = ((noMotionTimeout < (1*60) ? (1*60) : (noMotionTimeout > (255*60) ? (255*60) : noMotionTimeout))/60) as int // v2 as limits between 1 and 255 minutes
            log.info "Updating Inactivity timeout to $timeout minutes"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 5, configurationValue: [timeout]) // Set inactivity timeout in minutes
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 5) // Confirm inactivity timeout
        } else {
            log.info "Settings inactivity timeout to default"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 5, defaultValue: true) // Set inactivity timeout in minutes
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 5) // Confirm inactivity timeout
        }

        if (pirSensitivity && (pirSensitivity >= 1 && pirSensitivity <= 7)) {
            log.info "Updating PIR sensitivity to $pirSensitivity"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 6, configurationValue: [pirSensitivity]) // Set PIR sensitivity
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 6) // Confirm PIR sensitivity
        } else {
            log.info "Setting PIR sensitivity to default"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 6, defaultValue: true) // Set PIR sensitivity
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 6) // Confirm PIR sensitivity
        }
        
        if (ledConfig) {
            def ledMode = 3 // Default is flashing
            switch (ledConfig) {
                case "LED Off":
                	log.info "Setting LED mode to Off"
                	ledMode = 1
                    break
                    
                case "Pulsing":
                	log.info "Setting LED mode to Pulsing/Flashing"
                	ledMode = 2
                    break
                    
                case "Quick Flash":
                	log.info "Setting LED mode to Quick Flash"
                	ledMode = 3
                    break
                    
                case "Motion Flash":
                	log.info "Setting LED mode to Motion Flash"
                	ledMode = 4
                    break
                    
                default:
                	log.warn "Invalid LED mode: $ledConfig, settings to default Flashing"
                    break
            }
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 7, configurationValue: [ledMode])
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 7)
        } else {
            log.info "Setting LED Mode to default"
            cmds << zwave.configurationV1.configurationSet(parameterNumber: 7, defaultValue: true)
            cmds << zwave.configurationV1.configurationGet(parameterNumber: 7)
        }

		cmds << zwave.associationV1.associationSet(groupingIdentifier:1, nodeId:zwaveHubNodeId) // Set group association to identifier 1

        state.configSet = true // We're done, dont' update again unless requested
    }

    log.info "Requesting motion sensor, temperature and battery update"
    cmds << zwave.sensorBinaryV1.sensorBinaryGet() // Motion Sensor
    cmds << zwave.sensorMultilevelV5.sensorMultilevelGet(sensorType: 0x01) // current temperature
    cmds << zwave.sensorMultilevelV5.sensorMultilevelGet(sensorType: 0x03) // current light
    cmds << zwave.sensorMultilevelV5.sensorMultilevelGet(sensorType: 0x05) // current humidity
    cmds << zwave.batteryV1.batteryGet() // Battery level
    
	cmds << zwave.wakeUpV1.wakeUpNoMoreInformation() // All DONE
    
    //log.trace "Sending: $cmds"
    
    [event, getResponses(cmds)]
}

def zwaveEvent(physicalgraph.zwave.commands.batteryv1.BatteryReport cmd) {
	log.trace "BatteryReport: $cmd"
    
	def map = [ name: "battery", unit: "%" ]
	if (cmd.batteryLevel == 0xFF) {
		map.value = 1
		map.descriptionText = "${device.displayName} has a low battery"
		map.isStateChange = true
	} else {
		map.value = cmd.batteryLevel
	}
	state.lastbat = now()

    return [createEvent(map)]
}

def zwaveEvent(physicalgraph.zwave.commands.sensormultilevelv5.SensorMultilevelReport cmd) // Take the highest level 5 (for Z-Wave Plus Motion) which is backwards compatible with level 4 (for Z-Wave motion sensor)
{
	log.trace "SensorMultiLevelReport: $cmd"
    
	def map = [ displayed: true, value: cmd.scaledSensorValue.toString(), isStateChange: true ] // Report each temperature report even if the value hasn't changed
	switch (cmd.sensorType) {
		case 1:
			map.name = "temperature"
			def cmdScale = cmd.scale == 1 ? "F" : "C"
            map.value = ((convertTemperatureIfNeeded(cmd.scaledSensorValue, cmdScale, cmd.precision) as Double) + (tempOffset ?: 0)).round(1)
            map.unit = getTemperatureScale()
            map.descriptionText = "${device.displayName} temperature is ${map.value} °${map.unit}"
            if (displaySensor == "Temperature") { // Update summary display sensor
                sendEvent(name: "display", value: map.value + "°")
            }
			break;
            
		case 3:
        	map.name = "illuminance"
            if (luxMetric == "lux") {
                Double percValue = cmd.scaledSensorValue as Double
                map.value = interpolate(percentTable(), luxTable(), percValue).round(0) as Integer // no decimals, keep it clean
                map.unit = "lux"
            } else {
                map.value = (cmd.scaledSensorValue as Double).round(0) as Integer // no decimals, keep it clean
                map.unit = "%"
            }
        	map.descriptionText = "${device.displayName} light is ${map.value}${map.unit}"
        	sendEvent([name: "illuminanceX", value: map.value + map.unit])
            if (displaySensor == "Light") { // Update summary display sensor
                sendEvent(name: "display", value: map.value + map.unit)
            }
			break;
            
		case 5:
			map.name = "humidity"
			map.value = ((cmd.scaledSensorValue as Double) + (humidityOffset ?: 0)).round(0) as Integer // no decimals, keep it clean
			map.unit = "%"
            map.descriptionText = "${device.displayName} humidity is ${map.value}${map.unit}"
            if (displaySensor == "Humidity") { // Update summary display sensor
                sendEvent(name: "display", value: map.value + map.unit)
            }
			break;
            
		default:
        	log.warn "Unknown Sensor report sensor type: $cmd.sensorType"
            map.name = "unknown $cmd.sensorType"
			break;
	}
	createEvent(map)
}

def zwaveEvent(physicalgraph.zwave.Command cmd) {
	log.warn "Unhandled command: $cmd"
	createEvent(descriptionText: "$device.displayName: $cmd", displayed: false)
}

def zwaveEvent(physicalgraph.zwave.commands.manufacturerspecificv2.ManufacturerSpecificReport cmd) {
	def result = []

	def msr = String.format("%04X-%04X-%04X", cmd.manufacturerId, cmd.productTypeId, cmd.productId)
	log.debug "msr: $msr"
	updateDataValue("MSR", msr)

	result << createEvent(descriptionText: "$device.displayName MSR: $msr", isStateChange: false)
	result
}

def zwaveEvent(physicalgraph.zwave.commands.wakeupv2.WakeUpIntervalReport cmd) {
    log.trace "WakeUpIntervalReport $cmd"
}

// WakeUpIntervalCapabilitiesReport(defaultWakeUpIntervalSeconds: 3600, maximumWakeUpIntervalSeconds: 604800, minimumWakeUpIntervalSeconds: 600, wakeUpIntervalStepSeconds: 200)
def zwaveEvent(physicalgraph.zwave.commands.wakeupv2.WakeUpIntervalCapabilitiesReport cmd) {
    log.trace "WakeUpIntervalCapabilitiesReport $cmd"
}

def zwaveEvent(physicalgraph.zwave.commands.configurationv1.ConfigurationReport cmd) {
	log.trace "ConfigurationReport $cmd"
    def result = []
    def msg = null
    switch (cmd.parameterNumber) {
        case 1:
        	msg = "Temperature unit: °${cmd.configurationValue[0] ? "F" : "C"}"
            result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
            break
            
        case 2:
        	Double tempRT = ((cmd.configurationValue[0] as Double)/10).round(1)
        	msg = "Temperature reporting threshold: ${tempRT}°"
            result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
            break
            
        case 3:
        	msg = "Humidity reporting threshold: ${cmd.configurationValue[0]}%"
            result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
            break
            
        case 4:
        	msg = "Light reporting threshold: ${cmd.configurationValue[0]}%"
            result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
            break
            
        case 5:
        	msg = "Inactivity timeout: ${cmd.configurationValue[0] * (state.v3 ? 1 : 60)} seconds"
            result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
            break
            
        case 6:
        	msg = "PIR Sensitivity: ${cmd.configurationValue[0]}"
            result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
            break

        case 7:
        	switch (cmd.configurationValue[0]) {
                case 1:
	        		msg = "LED Mode: Off"
                	result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
    	            break
                
                case 2:
        			msg = "LED Mode: Temperature Pulsing/Motion Flashing"
                	result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
                    break
                    
                case 3:
                	msg = "LED Mode: Quick Flash"
                	result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
                    break
                    
                case 4:
                	msg = "LED Mode: Motion Flash"
                	result << createEvent(descriptionText: "$device.displayName $msg", displayed: true, isStateChange:false)
                    break

                default:
                    log.warn "Invalid LED Mode: ${cmd.configurationValue[0]}"
                	break
            }
            break
            
        default:
            log.warn "Unknown parameter"
            break
    }
    
    log.debug msg
    result
}

private getResponses(commands, delay=1200) {
    if (state.security) {
        response(delayBetween(commands.collect{ zwave.securityV1.securityMessageEncapsulation().encapsulate(it).format() }, delay))
    } else {
        response(delayBetween(commands.collect{ it.format() }, delay))
    }
}

private getResponse(command) {
    if (state.security) {
        response(zwave.securityV1.securityMessageEncapsulation().encapsulate(command).format())
    } else {
        response(command.format())
    }
}

private secure(physicalgraph.zwave.Command cmd) {
	if (state.security) {
		zwave.securityV1.securityMessageEncapsulation().encapsulate(cmd).format()
	} else {
		cmd.format()
	}
}

private secureSequence(commands, delay=200) {
	delayBetween(commands.collect{ secure(it) }, delay)
}

def configure() {
    // Force a refresh
    log.trace "Configure called\nZWInfo: ${zwaveInfo}"
    log.debug "Requested a refresh of sensors and settings at next wakeup"
    
    // Check if we have the new v3 version of the device with the updated firmware
    if (zwaveInfo.ver && zwaveInfo.ver == "17.09") {
        log.trace "Firmware v3 device detected"
        state.v3 = true
    } else {
        state.v3 = false
    }
    
    if (tempOffset) {
        log.trace "Temperature offset set to $tempOffset"
    }
    
    if (humidityOffset) {
        log.trace "Humidity offset set to $humidityOffset"
    }
        
    // Sanity check for polling interval
    if (manualPollInterval && ((manualPollInterval < 600) || (manualPollInterval > 604800) || (manualPollInterval % 200 != 0))) { // Range is 600 - 604800 with an interval of 200 seconds
    	log.error "Invalid Manual Poll Interval $manualPollInterval! It must be between 600 and 604800 and must be in interval of 200 seconds, NOT using Manual Polling"
    }
    
    if (ledConfig) {
        switch (ledConfig) {
            case "LED Off":
            case "Pulsing":
            case "Quick Flash":
            case "Motion Flash":
                break // All good

            default:
                log.warn "Invalid LED mode: $ledConfig, setting LED mode to default Flashing"
                break
        }
    }

    if (tempSensitivity && (tempSensitivity < 0.1 || tempSensitivity > 5.0)) {
    	log.error "Invalid temperature reporting threshold $tempSensitivity! It must be between 0.1 and 5.0, NOT updating temperature threshold"
    }
    
    if (luxSensitivity && (luxSensitivity < 5 || luxSensitivity > 50)) {
    	log.error "Invalid light reporting threshold $luxSensitivity! It must be between 5 and 50, NOT updating light threshold"
    }
    
    if (humiditySensitivity && (humiditySensitivity < 1 || humiditySensitivity > 50)) {
    	log.error "Invalid humidity reporting threshold $humiditySensitivity! It must be between 1 and 50, NOT updating humidity threshold"
    }
    
    if (state.v3) {
        if (noMotionTimeout && (noMotionTimeout < 15 || noMotionTimeout > (60*255))) { // v3 supports 15 to 60 but we're extending it to 15300
            log.error "V3 firmware: Invalid Inactivity timeout $noMotionTimeout! It must be between 15 and 15300 seconds, using minimum/maximum values for inactivity timeout"
        }
    } else {
        if (noMotionTimeout && (noMotionTimeout < 60 || noMotionTimeout > (60*255))) { // v2 support 60 to 15300
            log.warn "V2 firmware: Inactivity timeout $noMotionTimeout must be between 60 and 15300 seconds, using minimum/maximum values for inactivity timeout"
        }
    }
    
    if (pirSensitivity && (pirSensitivity < 1 || pirSensitivity > 7)) {
    	log.error "Invalid PIR Sensitivity $pirSensitivity! It must be between 1 and 7, NOT updating PIR sensitivity"
    }

    switch(displaySensor) {
        case "Temperature":
        	sendEvent(name: "display", value: device.currentValue("temperature") + "°")
            break
        
        case "Humidity":
        	sendEvent(name: "display", value: device.currentValue("humidity") + "%")
        	break
            
        case "Light":
        	sendEvent(name: "display", value: device.currentValue("illuminanceX"))
        	break
            
        case "Motion":
        default:
        	sendEvent(name: "display", value: device.currentValue("motion"))
        	break
    }

    state.configSet = false // We should set the inactivity timer
    state.wakeupSet = false // We should set the wake up interval
    
    // Configure is called at inclusion so we have a SMALL window to execute some commands here, won't make any differnce when called manually
    def cmds = []

    cmds += secureSequence([
        zwave.manufacturerSpecificV2.manufacturerSpecificGet(),
        zwave.batteryV1.batteryGet(),
        zwave.sensorBinaryV1.sensorBinaryGet(), // Motion Sensor
        zwave.sensorMultilevelV5.sensorMultilevelGet(sensorType: 0x01), // current temperature
        zwave.sensorMultilevelV5.sensorMultilevelGet(sensorType: 0x03), // current light
        zwave.sensorMultilevelV5.sensorMultilevelGet(sensorType: 0x05), // current humidity
    ], 500) // Small delay works since typically at inclusion the sensor is near the hub for the NIF command so there's no routing involved here

    // Don't do a no more wakeup here as the hub ends up queueing it becase it's a passive device and it interfers with the wakup command due to a delayed retry from the hub, the device will timeout by itself in 10 seconds
    //cmds << "delay 8000"
    //cmds << secure(zwave.wakeUpV1.wakeUpNoMoreInformation()) // We're done here
    
    return cmds
}

private Double interpolate(Double[] x, Double[] y, Double xi) {

    if (x.size() != y.size()) {
        throw new IllegalArgumentException("X and Y must be the same length");
    }
    if (x.size() == 1) {
        throw new IllegalArgumentException("X must contain more than one value");
    }
    Double[] dx = new Double[x.size() - 1];
    Double[] dy = new Double[x.size() - 1];
    Double[] slope = new Double[x.size() - 1];
    Double[] intercept = new Double[x.size() - 1];

    // Calculate the line equation (i.e. slope and intercept) between each point
    for (int i = 0; i < x.size() - 1; i++) {
        dx[i] = x[i + 1] - x[i];
        if (dx[i] == 0) {
            throw new IllegalArgumentException("X must be montotonic. A duplicate x-value was found: ${x[i]}");
        }
        if (dx[i] < 0) {
            throw new IllegalArgumentException("X must be sorted");
        }
        dy[i] = y[i + 1] - y[i];
        slope[i] = dy[i] / dx[i];
        intercept[i] = y[i] - x[i] * slope[i];
    }

    // Interpolate the value
    Double yi;
    int loc = Collections.binarySearch(x as List, xi);
    if (loc < -1) {
        loc = -loc - 2;
        yi = slope[loc] * xi + intercept[loc];
    }
    else {
        yi = y[loc];
    }

    return yi;
}

// THIS IS THE END OF THE FILE